import { ReviewResult, NodeReview, ReviewIssue } from '../types/review-types';

/**
 * Formats review results into well-structured GitHub PR comments
 */
export class PRCommentFormatter {
  
  /**
   * Generate main review comment with overall findings
   */
  static formatMainComment(reviewResult: ReviewResult): string {
    const { overallRecommendation, summary, nodeReviews, metadata } = reviewResult;
    
    const recommendationEmoji = this.getRecommendationEmoji(overallRecommendation);
    const sections = [];
    
    // Header with recommendation
    sections.push(`## 🤖 AI Code Review Results ${recommendationEmoji}`);
    sections.push('');
    sections.push(`**Recommendation:** ${this.formatRecommendation(overallRecommendation)}`);
    sections.push('');
    
    // Summary
    sections.push(`**Summary:** ${summary}`);
    sections.push('');
    
    // Key metrics
    sections.push('### 📊 Review Metrics');
    sections.push(`- **Nodes Reviewed:** ${metadata.totalNodes}`);
    sections.push(`- **Average Confidence:** ${(metadata.averageConfidence * 100).toFixed(1)}%`);
    sections.push(`- **Processing Time:** ${(reviewResult.processingTime / 1000).toFixed(1)}s`);
    sections.push('');
    
    // Critical/Major issues summary
    const criticalIssues = this.countIssuesBySeverity(nodeReviews, 'critical');
    const majorIssues = this.countIssuesBySeverity(nodeReviews, 'major');
    
    if (criticalIssues > 0 || majorIssues > 0) {
      sections.push('### ⚠️ Key Issues');
      if (criticalIssues > 0) {
        sections.push(`- **${criticalIssues} Critical Issue(s)** - Must be addressed before merge`);
      }
      if (majorIssues > 0) {
        sections.push(`- **${majorIssues} Major Issue(s)** - Should be addressed`);
      }
      sections.push('');
    }
    
    // Node breakdown
    sections.push('### 🔍 Detailed Findings');
    sections.push('');
    
    nodeReviews.forEach((nodeReview, index) => {
      sections.push(this.formatNodeReviewSummary(nodeReview, index + 1));
      sections.push('');
    });
    
    // Footer
    sections.push('---');
    sections.push('*🤖 Generated by AI Code Review Action powered by Claude AI*');
    sections.push('*💡 This review focuses on code quality, security, and maintainability*');
    
    return sections.join('\n');
  }
  
  /**
   * Generate detailed comment for a specific node
   */
  static formatNodeDetailComment(nodeReview: NodeReview): string {
    const sections = [];
    
    // Header
    sections.push(`## 🔍 Detailed Review: ${nodeReview.nodeName}`);
    sections.push('');
    sections.push(`**Node Type:** ${this.formatNodeType(nodeReview.nodeType)}`);
    sections.push(`**Confidence:** ${(nodeReview.confidence * 100).toFixed(1)}%`);
    sections.push(`**Risk Level:** ${this.formatRiskLevel(nodeReview.findings.riskLevel)}`);
    sections.push('');
    
    // Issues
    if (nodeReview.findings.issues.length > 0) {
      sections.push('### 🚨 Issues Found');
      sections.push('');
      
      nodeReview.findings.issues.forEach((issue, index) => {
        sections.push(this.formatIssue(issue, index + 1));
        sections.push('');
      });
    }
    
    // Strengths
    if (nodeReview.findings.strengths.length > 0) {
      sections.push('### ✅ Strengths');
      sections.push('');
      nodeReview.findings.strengths.forEach(strength => {
        sections.push(`- ${strength}`);
      });
      sections.push('');
    }
    
    // Test recommendations
    if (nodeReview.findings.testRecommendations.length > 0) {
      sections.push('### 🧪 Test Recommendations');
      sections.push('');
      nodeReview.findings.testRecommendations.forEach(test => {
        sections.push(`- [ ] ${test}`);
      });
      sections.push('');
    }
    
    return sections.join('\n');
  }
  
  /**
   * Generate concise inline comment for specific issues
   */
  static formatInlineComment(issue: ReviewIssue, nodeContext?: string): string {
    const severityEmoji = this.getSeverityEmoji(issue.severity);
    const sections = [];
    
    sections.push(`${severityEmoji} **${issue.severity.toUpperCase()}** (${issue.category})`);
    sections.push('');
    sections.push(issue.description);
    
    if (issue.suggestedFix) {
      sections.push('');
      sections.push(`**💡 Suggested fix:** ${issue.suggestedFix}`);
    }
    
    if (nodeContext) {
      sections.push('');
      sections.push(`*From: ${nodeContext}*`);
    }
    
    return sections.join('\n');
  }
  
  // Helper methods
  
  private static getRecommendationEmoji(recommendation: string): string {
    switch (recommendation) {
      case 'approve': return '✅';
      case 'request-changes': return '🚫';
      case 'needs-discussion': return '💬';
      default: return '❓';
    }
  }
  
  private static formatRecommendation(recommendation: string): string {
    switch (recommendation) {
      case 'approve': return '**APPROVE** - Changes look good to merge';
      case 'request-changes': return '**REQUEST CHANGES** - Critical issues must be addressed';
      case 'needs-discussion': return '**NEEDS DISCUSSION** - Review findings require team discussion';
      default: return recommendation;
    }
  }
  
  private static formatNodeType(nodeType: string): string {
    switch (nodeType) {
      case 'atomic-technical': return '⚛️ Atomic Technical';
      case 'business-feature': return '🏢 Business Feature';
      case 'integration-hybrid': return '🔗 Integration Hybrid';
      default: return nodeType;
    }
  }
  
  private static formatRiskLevel(riskLevel: string): string {
    switch (riskLevel) {
      case 'low': return '🟢 Low';
      case 'medium': return '🟡 Medium';
      case 'high': return '🟠 High';
      case 'critical': return '🔴 Critical';
      default: return riskLevel;
    }
  }
  
  private static getSeverityEmoji(severity: string): string {
    switch (severity) {
      case 'critical': return '🚨';
      case 'major': return '⚠️';
      case 'minor': return '⚡';
      case 'suggestion': return '💡';
      default: return '❓';
    }
  }
  
  private static formatIssue(issue: ReviewIssue, index: number): string {
    const severityEmoji = this.getSeverityEmoji(issue.severity);
    const sections = [];
    
    sections.push(`#### ${index}. ${severityEmoji} ${issue.severity.toUpperCase()} - ${issue.category}`);
    sections.push('');
    sections.push(issue.description);
    
    if (issue.suggestedFix) {
      sections.push('');
      sections.push(`**💡 Suggested fix:** ${issue.suggestedFix}`);
    }
    
    return sections.join('\n');
  }
  
  private static formatNodeReviewSummary(nodeReview: NodeReview, index: number): string {
    const nodeTypeIcon = this.getNodeTypeIcon(nodeReview.nodeType);
    const riskEmoji = this.getRiskEmoji(nodeReview.findings.riskLevel);
    const issueCount = nodeReview.findings.issues.length;
    
    const sections = [];
    sections.push(`#### ${index}. ${nodeTypeIcon} ${nodeReview.nodeName}`);
    sections.push(`**Risk:** ${riskEmoji} ${nodeReview.findings.riskLevel} | **Issues:** ${issueCount} | **Confidence:** ${(nodeReview.confidence * 100).toFixed(1)}%`);
    
    if (issueCount > 0) {
      const criticalCount = nodeReview.findings.issues.filter(i => i.severity === 'critical').length;
      const majorCount = nodeReview.findings.issues.filter(i => i.severity === 'major').length;
      const minorCount = nodeReview.findings.issues.filter(i => i.severity === 'minor').length;
      
      const issueCounts = [];
      if (criticalCount > 0) issueCounts.push(`${criticalCount} critical`);
      if (majorCount > 0) issueCounts.push(`${majorCount} major`);
      if (minorCount > 0) issueCounts.push(`${minorCount} minor`);
      
      if (issueCounts.length > 0) {
        sections.push(`*Issues: ${issueCounts.join(', ')}*`);
      }
    }
    
    return sections.join('\n');
  }
  
  private static getNodeTypeIcon(nodeType: string): string {
    switch (nodeType) {
      case 'atomic-technical': return '⚛️';
      case 'business-feature': return '🏢';
      case 'integration-hybrid': return '🔗';
      default: return '📁';
    }
  }
  
  private static getRiskEmoji(riskLevel: string): string {
    switch (riskLevel) {
      case 'low': return '🟢';
      case 'medium': return '🟡';
      case 'high': return '🟠';
      case 'critical': return '🔴';
      default: return '⚪';
    }
  }
  
  private static countIssuesBySeverity(nodeReviews: NodeReview[], severity: string): number {
    return nodeReviews.reduce((count, review) => 
      count + review.findings.issues.filter(issue => issue.severity === severity).length, 0
    );
  }
}